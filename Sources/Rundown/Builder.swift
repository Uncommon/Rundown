/// Used to build up the result generated by `ExampleBuilder`.
///
/// This type is intended to be internal to `ExampleBuilder`, but
/// must be public because of how a result builder works.
public struct Accumulator<Phase: AccumulatorPhase> {
  typealias AccumulatorData = [ObjectIdentifier: [any TestElement]]

  var data: AccumulatorData

  init() {
    self.data = .init()
  }

  init(data: AccumulatorData) {
    self.data = data
  }

  init<OtherPhase: AccumulatorPhase>(other: Accumulator<OtherPhase>) {
    self.data = other.data
  }

  func adding<E: TestElement>(_ element: E) -> Self where Phase: HookPhase {
    var result = self
    result.data.appendOrSet(.init(E.self), element)
    return result
  }

  func adding<E: TestExample>(_ example: E) -> Self where Phase == ExamplePhase {
    var result = self
    result.data.appendOrSet(.init(TestExample.self), example)
    return result
  }

  mutating func add<E: TestExample>(_ example: E) where Phase == ExamplePhase {
    data.appendOrSet(.init(TestExample.self), example)
  }

  mutating func add<P: AccumulatorPhase>(_ other: Accumulator<P>) {
    data.merge(other.data) { first, second in
      first + second
    }
  }

  func transitioned<P: HookPhase>(with element: some TestElement) -> Accumulator<P> {
    .init(data: data).adding(element)
  }

  func transitioned(with element: some TestExample) -> Accumulator<ExamplePhase> {
    .init(data: data).adding(element)
  }

  func phaseHooks<P: HookPhase>(_ phase: P.Type) -> [TestHook<P>] {
    data[.init(TestHook<P>.self)]?.compactMap { $0 as? TestHook<P> } ?? []
  }

  func examples() -> [TestExample] {
    data[.init(TestExample.self)]?.compactMap { $0 as? TestExample } ?? []
  }
}

@resultBuilder
public struct ExampleBuilder<Call: CallType> {
  // Hooks of the same sync type can repeat
  public static func buildPartialBlock<Phase: AccumulatorPhase, C: CallType>(
      accumulated: Accumulator<Phase>,
      next: TestHook<Phase, C>) -> Accumulator<Phase> {
    accumulated.adding(next)
  }

  // BeforeEach and BeforeAll can start
  public static func buildPartialBlock<Phase: BeforePhase>(first: TestHook<Phase, Call>) -> Accumulator<Phase> {
    .init().adding(first)
  }

  // BeforeEach can follow BeforeAll
  public static func buildPartialBlock<C: CallType>(
      accumulated: Accumulator<BeforeAllPhase>,
      next: TestHook<BeforeEachPhase, C>) -> Accumulator<BeforeEachPhase> {
    accumulated.transitioned(with: next)
  }

  // Examples can start and repeat
  public static func buildPartialBlock(first: any TestExample) -> Accumulator<ExamplePhase> {
    .init().adding(first)
  }
  public static func buildPartialBlock(
      accumulated: Accumulator<ExamplePhase>,
      next: any TestExample) -> Accumulator<ExamplePhase> {
    accumulated.adding(next)
  }

  // Examples can follow BeforeEach/BeforeAll
  public static func buildPartialBlock<Phase: BeforePhase>(
      accumulated: Accumulator<Phase>,
      next: any TestExample) -> Accumulator<ExamplePhase> {
    accumulated.transitioned(with: next)
  }

  // After hooks can follow examples
  public static func buildPartialBlock<Phase: AfterPhase>(
      accumulated: Accumulator<ExamplePhase>,
      next: TestHook<Phase, Call>) -> Accumulator<Phase> {
    accumulated.transitioned(with: next)
  }

  // AfterAll follows AfterEach
  public static func buildPartialBlock(
      accumulated: Accumulator<AfterEachPhase>,
      next: TestHook<AfterAllPhase, Call>) -> Accumulator<AfterAllPhase> {
    accumulated.transitioned(with: next)
  }

  // if/else for examples
  public static func buildEither<E: TestElement>(first component: E) -> E {
    component
  }
  public static func buildEither<E: TestElement>(second component: E) -> E {
    component
  }

  // Loops can end with examples or AfterEach/AfterAll
  public static func buildArray<P: FinalPhase>(_ components: [Accumulator<P>]) -> Accumulator<ExamplePhase> {
    var result = Accumulator<ExamplePhase>()

    for component in components {
      result.add(component)
    }
    return result
  }

  public static func buildPartialBlock<P>(first: Accumulator<P>) -> Accumulator<P> {
    first
  }

  // Examples or AfterEach/AfterAll can end
  public static func buildFinalResult<Phase: FinalPhase>(_ component: Accumulator<Phase>) -> ExampleGroup<Call> {
    // TODO: preserve the example description
    .init(description: "",
          traits: [],
          beforeAll: component.phaseHooks(BeforeAllPhase.self),
          beforeEach: component.phaseHooks(BeforeEachPhase.self),
          afterEach: component.phaseHooks(AfterEachPhase.self),
          afterAll: component.phaseHooks(AfterAllPhase.self),
          elements: component.examples())
  }

  // TODO: more messages for disallowed scenarios
  @available(*, unavailable, message: "Examples must not be empty")
  public static func buildBlock() -> Accumulator<ExamplePhase> {
    fatalError("unavailable")
  }
  @available(*, unavailable, message: "BeforeAll must precede BeforeEach")
  public static func buildPartialBlock<C: CallType>(
      accumulated: Accumulator<BeforeEachPhase>,
      next: TestHook<BeforeAllPhase, C>) -> Accumulator<BeforeEachPhase> {
    fatalError("unavailable")
  }
  @available(*, unavailable, message: "AfterEach must precede AfterAll")
  public static func buildPartialBlock<C: CallType>(
      accumulated: Accumulator<AfterAllPhase>,
      next: TestHook<AfterEachPhase, C>) -> Accumulator<AfterAllPhase> {
    fatalError("unavailable")
  }
  @available(*, unavailable, message: "Loop must end in example or after element")
  public static func buildArray<P: BeforePhase>(_ components: [Accumulator<P>]) -> Accumulator<P> {
    fatalError("unavailable")
  }
  @available(*, unavailable, message: "Group must have examples")
  public static func buildFinalResult<Phase: BeforePhase>(_ component: Accumulator<Phase>) -> ExampleGroup<Call> {
    fatalError("unavailable")
  }
}

extension ExampleBuilder where Call == AsyncCall {

}

extension ExampleBuilder where Call == SyncCall {

}

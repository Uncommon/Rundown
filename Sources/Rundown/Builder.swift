/// Used to build up the result generated by `ExampleBuilder`.
///
/// This type is intended to be internal to `ExampleBuilder`, but
/// must be public because of how a result builder works.
public struct Accumulator<Phase: AccumulatorPhase> {
  typealias AccumulatorData = [ObjectIdentifier: [any TestElement]]

  var data: AccumulatorData

  init() {
    self.data = .init()
  }

  init(data: AccumulatorData) {
    self.data = data
  }

  init<OtherPhase: AccumulatorPhase>(other: Accumulator<OtherPhase>) {
    self.data = other.data
  }

  func adding<E: TestElement>(_ element: E) -> Self where Phase: HookPhase {
    var result = self
    result.data.appendOrSet(.init(E.self), element)
    return result
  }

  func adding<E: TestExample>(_ example: E) -> Self where Phase == ExamplePhase {
    var result = self
    result.data.appendOrSet(.init((any TestExample).self), example)
    return result
  }

  mutating func add<E: TestExample>(_ example: E) where Phase == ExamplePhase {
    data.appendOrSet(.init((any TestExample).self), example)
  }

  mutating func add<P: AccumulatorPhase>(_ other: Accumulator<P>) {
    data.merge(other.data) { first, second in
      first + second
    }
  }

  func transitioned<P: HookPhase>(with element: some TestElement) -> Accumulator<P> {
    .init(data: data).adding(element)
  }

  func transitioned(with element: some TestExample) -> Accumulator<ExamplePhase> {
    .init(data: data).adding(element)
  }

  func phaseHooks<P: HookPhase, C: CallType>(_ phase: P.Type) -> [TestHook<P, C>] {
    data[.init(TestHook<P, C>.self)]?.compactMap { $0 as? TestHook<P, C> } ?? []
  }
  
  func aroundEachHooks<C: CallType>() -> [AroundEach<C>] {
    data[.init(AroundEach<C>.self)]?.compactMap { $0 as? AroundEach<C> } ?? []
  }

  func examples() -> [any TestExample] {
    data[.init((any TestExample).self)]?.compactMap { $0 as? (any TestExample) } ?? []
  }
}

@resultBuilder
public struct ExampleBuilder<Call: CallType> {
  // Hooks of the same sync type can repeat
  public static func buildPartialBlock<Phase: AccumulatorPhase, C: CallType>(
      accumulated: Accumulator<Phase>,
      next: TestHook<Phase, C>) -> Accumulator<Phase> {
    accumulated.adding(next)
  }

  // BeforeAll and BeforEach can start
  public static func buildPartialBlock<Phase: BeforePhase>(first: TestHook<Phase, Call>) -> Accumulator<Phase> {
    .init().adding(first)
  }
  
  // AroundEach can start
  public static func buildPartialBlock(first: AroundEach<Call>) -> Accumulator<AroundEachPhase> {
    .init().adding(first)
  }
  
  // AroundEach can repeat
  public static func buildPartialBlock(
      accumulated: Accumulator<AroundEachPhase>,
      next: AroundEach<Call>) -> Accumulator<AroundEachPhase> {
    accumulated.adding(next)
  }

  // AroundEach can follow BeforeAll
  public static func buildPartialBlock(
      accumulated: Accumulator<BeforeAllPhase>,
      next: AroundEach<Call>) -> Accumulator<AroundEachPhase> {
    accumulated.transitioned(with: next)
  }

  // BeforeEach can follow BeforeAll
  public static func buildPartialBlock<C: CallType>(
      accumulated: Accumulator<BeforeAllPhase>,
      next: TestHook<BeforeEachPhase, C>) -> Accumulator<BeforeEachPhase> {
    accumulated.transitioned(with: next)
  }

  // BeforeEach can follow AroundEach
  public static func buildPartialBlock<C: CallType>(
      accumulated: Accumulator<AroundEachPhase>,
      next: TestHook<BeforeEachPhase, C>) -> Accumulator<BeforeEachPhase> {
    accumulated.transitioned(with: next)
  }

  // Examples can start and repeat
  public static func buildPartialBlock(first: any TestExample<Call>) -> Accumulator<ExamplePhase> {
    .init().adding(first)
  }
  public static func buildPartialBlock(
      accumulated: Accumulator<ExamplePhase>,
      next: any TestExample<Call>) -> Accumulator<ExamplePhase> {
    accumulated.adding(next)
  }

  // Examples can follow BeforeEach/BeforeAll
  public static func buildPartialBlock<Phase: BeforePhase>(
      accumulated: Accumulator<Phase>,
      next: any TestExample<Call>) -> Accumulator<ExamplePhase> {
    accumulated.transitioned(with: next)
  }

  // After hooks can follow examples
  public static func buildPartialBlock<Phase: AfterPhase>(
      accumulated: Accumulator<ExamplePhase>,
      next: TestHook<Phase, Call>) -> Accumulator<Phase> {
    accumulated.transitioned(with: next)
  }

  // AfterAll follows AfterEach
  public static func buildPartialBlock(
      accumulated: Accumulator<AfterEachPhase>,
      next: TestHook<AfterAllPhase, Call>) -> Accumulator<AfterAllPhase> {
    accumulated.transitioned(with: next)
  }

  // if/else for examples
  public static func buildEither<E: TestElement>(first component: E) -> E {
    component
  }
  public static func buildEither<E: TestElement>(second component: E) -> E {
    component
  }

  // Loops can end with examples or AfterEach/AfterAll
  public static func buildArray<P: FinalPhase>(_ components: [Accumulator<P>]) -> Accumulator<ExamplePhase> {
    var result = Accumulator<ExamplePhase>()

    for component in components {
      result.add(component)
    }
    return result
  }

  public static func buildPartialBlock<P>(first: Accumulator<P>) -> Accumulator<P> {
    first
  }

  // Examples or AfterEach/AfterAll can end
  public static func buildFinalResult<Phase: FinalPhase>(_ component: Accumulator<Phase>) -> ExampleGroup<Call> {
    // TODO: preserve the example description
    .init(description: "",
          traits: [],
          beforeAll: component.phaseHooks(BeforeAllPhase.self),
          aroundEach: component.aroundEachHooks(),
          beforeEach: component.phaseHooks(BeforeEachPhase.self),
          afterEach: component.phaseHooks(AfterEachPhase.self),
          afterAll: component.phaseHooks(AfterAllPhase.self),
          elements: component.examples())
  }

  // TODO: more messages for disallowed scenarios
  @available(*, unavailable, message: "Examples must not be empty")
  public static func buildBlock() -> Accumulator<ExamplePhase> {
    fatalError("unavailable")
  }
  @available(*, unavailable, message: "BeforeAll must precede BeforeEach")
  public static func buildPartialBlock<C: CallType>(
      accumulated: Accumulator<BeforeEachPhase>,
      next: TestHook<BeforeAllPhase, C>) -> Accumulator<BeforeEachPhase> {
    fatalError("unavailable")
  }
  @available(*, unavailable, message: "BeforeAll cannot appear after examples")
  public static func buildPartialBlock<C: CallType>(
      accumulated: Accumulator<ExamplePhase>,
      next: TestHook<BeforeAllPhase, C>) -> Accumulator<ExamplePhase> {
    fatalError("unavailable")
  }
  @available(*, unavailable, message: "BeforeEach cannot appear after examples")
  public static func buildPartialBlock<C: CallType>(
      accumulated: Accumulator<ExamplePhase>,
      next: TestHook<BeforeEachPhase, C>) -> Accumulator<ExamplePhase> {
    fatalError("unavailable")
  }
  @available(*, unavailable, message: "AfterEach must precede AfterAll")
  public static func buildPartialBlock<C: CallType>(
      accumulated: Accumulator<AfterAllPhase>,
      next: TestHook<AfterEachPhase, C>) -> Accumulator<AfterAllPhase> {
    fatalError("unavailable")
  }
  @available(*, unavailable, message: "AroundEach cannot appear after examples")
  public static func buildPartialBlock(
    accumulated: Accumulator<ExamplePhase>,
    next: AroundEach<Call>) -> Accumulator<ExamplePhase> {
      fatalError("unavailable")
    }
  @available(*, unavailable, message: "Loop must end in example or 'after' element")
  public static func buildArray<P: BeforePhase>(_ components: [Accumulator<P>]) -> Accumulator<P> {
    fatalError("unavailable")
  }
  @available(*, unavailable, message: "Group must have examples")
  public static func buildFinalResult<Phase: BeforePhase>(_ component: Accumulator<Phase>) -> ExampleGroup<Call> {
    fatalError("unavailable")
  }
  @available(*, unavailable, message: "Group must have examples")
  public static func buildFinalResult(_ component: Accumulator<AroundEachPhase>) -> ExampleGroup<Call> {
    fatalError("unavailable")
  }
}

// In an async spec, convert sync elements to async
public extension ExampleBuilder where Call == AsyncCall {
  // Before hooks come first
  static func buildPartialBlock<Phase: BeforePhase>(first: TestHook<Phase, SyncCall>) -> Accumulator<Phase> {
    .init().adding(TestHook<Phase, AsyncCall>(fromSync: first))
  }
  // Hook repeat
  static func buildPartialBlock<Phase: AccumulatorPhase>(
    accumulated: Accumulator<Phase>,
    next: TestHook<Phase, SyncCall>) -> Accumulator<Phase> {
    accumulated.adding(TestHook<Phase, AsyncCall>(fromSync: next))
  }
  // BeforeEach can follow BeforeAll
  static func buildPartialBlock(
      accumulated: Accumulator<BeforeAllPhase>,
      next: TestHook<BeforeEachPhase, SyncCall>) -> Accumulator<BeforeEachPhase> {
    accumulated.transitioned(with: TestHook<BeforeEachPhase, AsyncCall>(fromSync: next))
  }
  // BeforeEach can follow AroundEach
  static func buildPartialBlock(
      accumulated: Accumulator<AroundEachPhase>,
      next: TestHook<BeforeEachPhase, SyncCall>) -> Accumulator<BeforeEachPhase> {
    accumulated.transitioned(with: TestHook<BeforeEachPhase, AsyncCall>(fromSync: next))
  }
  // Examples come first
  static func buildPartialBlock(first: any TestExample<SyncCall>) -> Accumulator<ExamplePhase> {
    .init().adding(first)
  }
  // Examples follow examples
  static func buildPartialBlock(
    accumulated: Accumulator<ExamplePhase>,
    next: any TestExample<SyncCall>) -> Accumulator<ExamplePhase> {
      accumulated.adding(next)
  }
  // Examples follow Before hooks
  static func buildPartialBlock<Phase: BeforePhase>(
    accumulated: Accumulator<Phase>,
    next: any TestExample<SyncCall>) -> Accumulator<ExamplePhase> {
    accumulated.transitioned(with: next)
  }
  // AfterEach/AfterAll follows examples
  static func buildPartialBlock<Phase: AfterPhase>(
      accumulated: Accumulator<ExamplePhase>,
      next: TestHook<Phase, SyncCall>) -> Accumulator<Phase> {
    accumulated.transitioned(with: TestHook<Phase, AsyncCall>(fromSync: next))
  }

  // AroundEach can't be converted from sync to async because it
  // would require passing the new async callback to the old sync
  // callback, and there's no good way to make that work.
  // This also makes sense because every AroundEach must be able
  // to handle every example in the group, so if any are async then
  // every AroundEach must also be async.
  @available(*, unavailable, message: "Every aroundEach must be async in an async test")
  static func buildPartialBlock(first: AroundEach<SyncCall>) -> Accumulator<AroundEachPhase> {
    fatalError("unavailable")
  }
  @available(*, unavailable, message: "Every aroundEach must be async in an async test")
  static func buildPartialBlock<Phase: AccumulatorPhase>(
    accumulated: Accumulator<Phase>,
    next: AroundEach<SyncCall>) -> Accumulator<AroundEachPhase> {
    fatalError("unavailable")
  }
}
